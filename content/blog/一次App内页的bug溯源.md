---
title: '一次App内页的bug溯源'
date: 2019-09-02
---

### 写在前面

上一篇博客中提到的业务，这次引发了另一个bug

### 背景信息

上一次的H5页面上线有段时间了，客户端同学终于赶上了进度，把页面用到了App里更多的地方。

这次bug的主角是2个页面，一个列表页（以下简称L），一个详情页（以下简称D）。L由内嵌webview为容器，作为App一级页面tabView中的一个tab；点击L打开覆盖全屏的webview，展示D。很常见的一种App导航配置。

需要说明一点，这次的2个页面都有CSRF校验。正是这个CSRF校验，引发了后续的一系列bug。

### BUG排查过程

1. 无意发现bug

   iOS开发哥们反馈L和D在iPad上有bug，聊着聊着突然发现，页面从L到D，随便点击D内一个按钮再返回，L里所有功能按钮点击统统报错。

   按钮的请求都有CSRF校验，当时很自然想到了应该是CSRF校验失败，否则很难解释这么大面积的功能失灵。

   **结论：CSRF校验失败？**

2. CSRF校验失败

   抓包看了请求的返回数据，也麻烦搭档查了日志，确认是校验失败引起的bug。

   **结论：确认CSRF校验失败**

3. 只有iOS出现bug，确认直接原因

   于是交给了搭档排查后台。我也不想闲着，试了试Android的页面，并没有像iOS一样出现bug。

   原因一目了然，Android 返回的时候，会重新请求页面，而iOS使用缓存，不会请求。

   到这步再一次确认了就是CSRF的问题，并且肯定因为页面跳转引起了CSRF token变化，而iOS仍然使用缓存的旧页面（即请求还是用旧token），所以无法通过校验以致报错。

   **结论：页面切换导致CSRF token改变，iOS使用缓存所以无法通过校验**

4. 试图保持token失败

   搭档的排查没有发现原因，但给了一条信息：token会存一个对应的key在cookie里，如果后台渲染页面时发现cookie中有这个key，就不会刷新token。

   当时也没细想，觉得既然如此，那么跳转页面的时候把key写入local storage，D页面加载时再取出并写入cookie就可以了。居然丝毫没发现这个做法逻辑上的漏洞。

   很自然的，失败了。

   抓包数据发现不论怎么写，D页面加载时cookie里都没有这个key。再一想，在回写cookie的时候页面都已经加载，怎么会有效果...更不要说只从L页写local storage，这个key在以后被D页取出的时候很可能存在过期的情况，毕竟D页自身可以刷新，还可能从其他页面跳转过来，并非只有L->D一种路径。要想生效，那么必须在D页请求之前，cookie中就有这个key了，要实现这个目标，只能通过共享cookie。

   死路一条，放弃。

   **结论：cookie只能被共享给D页，否则页面总会新发起一次请求刷新token**

5. 共享cookie带来的矛盾

   抓包继续看，发现D页加载时cookie里没有key，随后请求接口时cookie里key出现了，说明key是页面加载时新请求到的。这个key和L页的不一样。但是当从D返回L时，二者的key相同了。说明某个时候，D修改了L的cookie，或者更进一步假设，D修改了cookie，因为cookie二者共享，所以L的cookie也变化了。

   但马上就可以发现一个新的矛盾：

   - 矛盾1：既然共享cookie，为什么D加载时没有key？

   - 矛盾2：如果不共享cookie，为什么D的key变化后能同步给L？

   假设不共享，那么谁改动了cookie？是web后台还是客户端？什么时候改动的？

   考虑L页的iOS缓存，正常情况下web后台唯一写cookie的时机是在D页加载时，因为此时D页cookie中没有key这个字段。再次返回L页因为缓存缘故，并没有任何网络请求，没有改变cookie的机会。那么只能是客户端有动作了。

   但这个假设又有挥之不去的另一个矛盾，除了key之外的字段都是一样的，只能认为这些内容是共享的。那么这又如何解释呢？好迷

   **结论：L和D共享了cookie？不共享cookie？客户端有修改cookie？**

6. chrome再现bug场景

   

7. 确认bug根源

   

