{"data":{"markdownRemark":{"id":"1af98d8b-3921-5496-8ce8-b5758d800bf5","excerpt":"写在前面：这是一篇译文，是原作者系列文章的第一篇，第二篇主题是 CSS 和 第三篇是 HTML。 TL ,  DR , 简单总结如下：  发展阶段 新引入工具 优点 缺点 工具解决问题 工具引入的新问题 原始阶段 无 模型简单易理解，无需其他工具…","html":"<p>写在前面：这是一篇译文，是原作者系列文章的第一篇，第二篇主题是 CSS 和 第三篇是 HTML。</p>\n<p><strong>TL</strong>, <strong>DR</strong>, 简单总结如下： </p>\n<table>\n<thead>\n<tr>\n<th>发展阶段</th>\n<th>新引入工具</th>\n<th>优点</th>\n<th>缺点</th>\n<th>工具解决问题</th>\n<th>工具引入的新问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>原始阶段</td>\n<td>无</td>\n<td>模型简单易理解，无需其他工具</td>\n<td>1.没有模块机制，手工添加script标签以全局变量形式导入第三方JS库<br>2. 库版本升级需手工下载更新，过程繁琐</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td>包管理器阶段</td>\n<td>bower->npm,yarn</td>\n<td>1.JS库下载更新由包管理器工具实现自动化<br>2.通过<code class=\"language-text\">package.json</code>文件共享项目配置</td>\n<td>1.前端开发需要掌握命令行工具 <br>2.导入第三方JS库需要人工查找其在<code class=\"language-text\">node_modules</code>中的路径</td>\n<td>原始阶段-缺点-2</td>\n<td>包管理器阶段-缺点-1，2</td>\n</tr>\n<tr>\n<td>模块打包工具阶段</td>\n<td>Browserify->Webpack</td>\n<td>1.支持模块导入，不必手工添加script标签<br>2.自动发现模块路径，不必人工查找<br>3.构建打包后只有1个js文件，部署容易</td>\n<td>1.引入构建工具,工具复杂度提高<br>2.模块机制不兼容浏览器，不得已在开发中增加构建过程</td>\n<td>包管理器阶段-缺点-2</td>\n<td>模块打包工具阶段-缺点-1，2</td>\n</tr>\n<tr>\n<td>转换代码阶段</td>\n<td>CoffeScript->babel, TypeScript</td>\n<td>1.全面支持新语言特性，代码更简单<br> 2.提升了编程语言及生态的发展</td>\n<td>1.开发工具链复杂度再次提高<br>2.修改代码后查看效果必须人工重新构建，降低开发效率</td>\n<td>无</td>\n<td>转换代码阶段-缺点-1，2</td>\n</tr>\n<tr>\n<td>任务管理工具阶段</td>\n<td>grunt, gulp-> npm script</td>\n<td>1.构建过程自动化程度提高，开发效率提升</td>\n<td>无</td>\n<td>转换代码阶段-缺点-1，2</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>作者：<a href=\"https://medium.com/@peterxjang?source=post_header_lockup\">Peter Jang</a><br>\n原文名：<a href=\"https://medium.com/the-node-js-collection/modern-javascript-explained-for-dinosaurs-f695e9747b70\">Modern JavaScript Explained For Dinosaurs</a><br>\n原文于 2017 年 10 月 19 日发表于 medium</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"#%E5%86%99%E7%BB%99%E6%81%90%E9%BE%99%E7%9A%84%E7%8E%B0%E4%BB%A3-javascript-%E6%8C%87%E5%8D%97\">写给恐龙的现代 JavaScript 指南</a></p>\n<ul>\n<li><a href=\"#%E4%BC%A0%E7%BB%9F-javascript-%E6%96%B9%E5%BC%8F\">传统 JavaScript 方式</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-javascript-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8npm\">使用 JavaScript 包管理器（npm）</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-javascript-%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7webpack\">使用 JavaScript 模块打包工具(webpack)</a></li>\n<li><a href=\"#%E8%BD%AC%E6%8D%A2%E4%BB%A3%E7%A0%81%E4%BB%A5%E6%94%AF%E6%8C%81%E6%96%B0%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7babel\">转换代码以支持新语言特性（babel）</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7npm-scripts\">使用任务管理工具（npm scripts）</a></li>\n<li><a href=\"#%E7%BB%93%E8%AF%AD\">结语</a></li>\n</ul>\n</li>\n</ul>\n<h3>写给恐龙的现代 JavaScript 指南</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/992/1*H8PH-HaV43gZyBJz0mJHxA.png\">\nImages from <a href=\"http://www.qwantz.com/\">Dinosaur Comics</a> by <a href=\"https://twitter.com/ryanqnorth\">Ryan North</a></p>\n<p>如果没有一直关注的话，学习现代 JavaScript 并非易事。它的语言生态发展和变化太快，甚至让人难以理解不同工具期望解决的问题。我从 1998 年就开始编程了，但直到 2014 年才开始认真学习 JavaScript。我还记得当时偶然看到<a href=\"http://browserify.org/\">Browserify</a>，它的标语是</p>\n<blockquote>\n<p>\"Browserify 负责打包所有依赖，实现在浏览器中引入各种模块\"</p>\n</blockquote>\n<p>我完全不懂这句话什么意思，还在拼命想这东西对开发者有什么用。</p>\n<p>本文会介绍 JavaScript 发展的历史背景，说明 JavaScript 工具是怎样发展到 2017 年现在这种状态的。我们会从头开始，只用 HTML 和 JavaScript 开发一个示例网站。然后逐步引入各种不同工具，逐个说明每个工具试图解决的问题。当了解历史轨迹之后，你会更好的学习并适应未来不断变化的 JavaScript 生态。开始吧！</p>\n<h4>传统 JavaScript 方式</h4>\n<p>我们先从只含 HTML 和 JavaScript 的传统网站开始，它需要手动下载和链接文件。下面是一个链接到 JS 文件的简单的<code class=\"language-text\">index.html</code>文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">&lt;!-- index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript Example&lt;/title&gt;\n  &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Hello from HTML!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div>\n<p><code class=\"language-text\">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>这一行引用了同文件夹内的另一个 JavaScript 文件，名为<code class=\"language-text\">index.js</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">// index.js\nconsole.log(&quot;Hello from JavaScript!&quot;);</code></pre></div>\n<p>这就是一个网站了！现在假设你想导入别人写的库，比如说<a href=\"http://momentjs.com/\">moment.js</a>(它把时间格式化为可读形式)。 假设你可以像下面这样使用<code class=\"language-text\">moment</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">moment().startOf(&#39;day&#39;).fromNow();        // 20 hours ago</code></pre></div>\n<p>但你首先得在网站里引入 moment.js。在 moment.js 首页上能看到以下说明：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/992/1*ef7OX37jr--Jc38ZxO97Iw.png\"></p>\n<p>右侧<strong>Install</strong>这一栏里有很多内容。暂时先忽略，我们可以下载<code class=\"language-text\">moment.min.js</code>文件到网站文件夹里，并在<code class=\"language-text\">index.html</code>里引用它。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">&lt;!-- index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Example&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;\n  &lt;script src=&quot;moment.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Hello from HTML!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div>\n<p>注意<code class=\"language-text\">moment.min.js</code>比<code class=\"language-text\">index.js</code>先加载，这样你就可以在<code class=\"language-text\">index.js</code>里使用<code class=\"language-text\">moment</code>函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">// index.js\nconsole.log(&quot;Hello from JavaScript!&quot;);\nconsole.log(moment().startOf(&#39;day&#39;).fromNow());</code></pre></div>\n<p>这就是使用 JS 库开发网站的方式！好处是非常容易理解。不足在于每次库更新都要下载它的新版本，这很繁琐。</p>\n<h4>使用 JavaScript 包管理器（npm）</h4>\n<p>2010 年开始，一批互相竞争的 JavaScript 包管理器出现，通过从中心仓库下载和更新库实现了这个过程的自动化。<a href=\"https://bower.io/\">Bower</a>可以说是 2013 年最受欢迎的包管理器，但最终在 2015 年左右被<a href=\"https://www.npmjs.com/\">npm</a>取代。（2016 年下半年，<a href=\"https://yarnpkg.com/en/\">yarn</a>作为 npm 的替代品吸引了大量关注，但本质上它仍然使用 npm 包管理技术）<br>\n说明一下，npm 起初只是<a href=\"https://nodejs.org/\">node.js</a>的专用包管理器。node 运行在服务端，不是前端。前端的包管理器选择运行在服务器端的库，有点不正常啊。</p>\n<blockquote>\n<p>注：使用包管理器需要掌握命令行，过去的前端开发中并没有这个要求。如果你从来没用过，可以从这个<a href=\"https://www.learnenough.com/command-line-tutorial\">入门指南</a>开始。总而言之，掌握命令行是现代 JavaScript 中一项重要内容（命令行也让其它领域的开发成为可能）。</p>\n</blockquote>\n<p>看一下如何使用 npm 自动安装 moment.js。如果你已经安装了 node.js，你就有了 npm。你就可以通过命令行访问<code class=\"language-text\">index.html</code>的文件夹并输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"command line\"><pre class=\"language-command line\"><code class=\"language-command line\">$ npm init</code></pre></div>\n<p>之后会弹出一系列问题（直接选默认就行，一直点回车），并生成<code class=\"language-text\">package.json</code>文件。这是 npm 用来保存项目信息的配置文件。默认选项的<code class=\"language-text\">package.json</code>的内容如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-project-name\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"description\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"main\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"test\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"author\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"license\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ISC\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们现在可以按照 moment.js 主页的说明安装了，命令行输入下面这条命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"command line\"><pre class=\"language-command line\"><code class=\"language-command line\">$ npm install moment --save</code></pre></div>\n<p>这条命令做了 2 件事情：一，它下载 moment.js 的所有代码，并保存在<code class=\"language-text\">node_modules</code>文件夹里。二，它自动修改<code class=\"language-text\">package.json</code>文件，把 moment.js 作为项目依赖。</p>\n<pre><code>{\n  \"name\": \"modern-javascript-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  <b>\"dependencies\": {\n    \"moment\": \"^2.22.2\"\n  }</b>\n}</code></pre>\n<p>这在后面与他人共享项目时很有用——不再共享<code class=\"language-text\">node_modules</code>文件夹（这个文件夹可能很大），只需要共享<code class=\"language-text\">package.json</code>文件，其他人就能通过<code class=\"language-text\">npm install</code>自动安装需要的包。</p>\n<p>我们再也不用手动下载 moment.js 了，可以使用 npm 自动下载和更新。打开<code class=\"language-text\">node_modules</code>文件夹，可以看到<code class=\"language-text\">moment.min.js</code>文件出现在<code class=\"language-text\">node_modules/moment/min</code>文件夹。这样就可以在<code class=\"language-text\">index.html</code>中链接下载好的<code class=\"language-text\">moment.min.js</code>版本：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token comment\">&lt;!-- index.html --></span>\n<span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>JavaScript Example<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n\n    --\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>node_modules/moment/min/moment.min.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    --\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>index.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Hello from HTML!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>优点是我们现在可以通过命令行使用 npm 下载和更新包。不足是现在得从<code class=\"language-text\">node_modules</code>里找到每个包的路径并手动添加到 HTML 中。太麻烦了，下面会谈到怎么让这个过程也实现自动化。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/992/1*GeEETvRqyG4o7SZdbU2Guw.png\"></p>\n<h4>使用 JavaScript 模块打包工具(webpack)</h4>\n<p>大多数编程语言支持将一个文件的代码导入到另一个文件。JavaScript 开始并没有这个功能，因为 JavaScript 开始只在浏览器运行，没有访问客户端电脑文件系统的权限（因为安全原因）。所以一直以来，组织多文件的 JavaScript 代码需要将各文件变量作为全局导入。</p>\n<p>我们在上面 moment.js 例子里也是这么做的——HTML 加载整个<code class=\"language-text\">moment.min.js</code>文件，定义了一个全局变量<code class=\"language-text\">moment</code>，这样后加载的文件都可以访问它（不管他们是否需要访问这个变量）</p>\n<p>2009 年，名为 CommonJS 的项目启动了。它旨在规范浏览器端以外的 JavaScript 生态。CommonJS 的大部分内容是关于模块的标准，它让 JavaScript 像其他编程语言一样，最终实现了跨文件导入和导出代码的功能，结束了依赖全局变量的时代。CommonJS 标准最广为人知的实现是 node.js 。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/992/1*xeF1flp1zDLLJ4j7rDQ6-Q.png\"></p>\n<p>之前提过，node.js 是在服务端运行的 JavaScript。之前的例子用 node.js 模块表示的话，是这样的。HTML 不再通过 script 标签加载<code class=\"language-text\">moment.min.js</code>，而是直接在 JavaScript 文件中导入：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// index.js</span>\n<span class=\"token keyword\">var</span> moment <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"moment\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello from JavaScript!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">moment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">startOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"day\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">fromNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这是 node.js 里加载模块的方式。它在 node.js 中一切正常，因为 node 是服务端语言，能够访问计算机文件系统。node.js 也知道每个 npm 模块的路径，因此只需要使用<code class=\"language-text\">require(&#39;moment&#39;)</code>语句，而不再需要<code class=\"language-text\">require(&#39;./node_modules/moment/min/moment.min.js)</code>(译注：即指明模块具体路径)——非常好。</p>\n<p>但这也只在 node.js 里行的通了，如果你在浏览器里使用这种方式，得到的只是“<code class=\"language-text\">require</code>未定义”的错误。浏览器没有访问文件系统的权限，因此通过这种方式加载模块非常困难——文件加载只能动态完成，要么是同步的（这会降低执行速度），要么是异步的（会出现时间不一致的问题）。</p>\n<p>于是模块打包工具应运而生。JavaScript 模块打包工具通过构建过程（过程中有文件访问权限）绕开了这个问题，它输出一个兼容浏览器的最终文件（即不需要访问文件系统）。这样就需要打包工具找到所有浏览器不兼容的<code class=\"language-text\">require</code>语句，将其替换成依赖文件的真实内容。最终输出是单个打包好的 JavaScript 文件（并且没有 require 语句）！</p>\n<p>曾经最流行的打包工具是<a href=\"http://browserify.org/\">Browserify</a>，它在 2011 年发布，首先在前端支持 node.js 格式的 require 语句（这最终成就了 npm，让它成了前端包管理器）。2015 年左右，<a href=\"https://webpack.github.io/\">webpack</a>后来居上，成为最广泛使用的打包工具（前端框架 React 的普及推动了这一过程，因为 React 充分利用了 webpack 的各种特性）。</p>\n<p>看看 webpack 怎么让前面<code class=\"language-text\">require(&#39;moment&#39;)</code>这个例子实现兼容浏览器的。首先需要在项目中安装 webpack。webpack 自身就是一个 npm 包，可以通过命令行安装：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install webpack webpack-cli --save-dev</code></pre></div>\n<p>注意安装的是 2 个包——webpack 和 webpack-cli（后者支持通过命令行使用 webpack）。再看 <code class=\"language-text\">--save-dev</code>参数——这个参数表示将安装包作为开发依赖保存，意思是安装包在开发环境中使用，但不会部署在生产服务器上。可以在<code class=\"language-text\">package.json</code>文件中看到，文件会自动更新：</p>\n<pre>{\n  \"name\": \"modern-javascript-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"moment\": \"^2.19.1\"\n  },\n  <b>\"devDependencies\": {\n    \"webpack\": \"^4.17.1\",\n    \"webpack-cli\": \"^3.1.0\"\n  }</b>\n}</pre>\n<p>现在<code class=\"language-text\">node_modules</code>文件夹里安装好了 webpack 和 webpack-cli 包。你可以在命令行里使用 webpack-cli：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./node_modules/.bin/webpack index.js --mode=development</code></pre></div>\n<p>这条命令将会运行安装好的 webpack，从<code class=\"language-text\">index.js</code>文件开始，搜索全部<code class=\"language-text\">require</code>语句，将它替换为合适的代码，最终创建单个输出文件（默认路径是<code class=\"language-text\">dist/main.js</code>）。<code class=\"language-text\">--mode=development</code>参数让 JavaScript 代码保持可读性，而<code class=\"language-text\">--mode=production</code>参数则会输出（不可读的）最小化的文件。</p>\n<p>得到 webpack 的<code class=\"language-text\">dist/main.js</code>输出文件后，我们就可以在浏览器中用它取代<code class=\"language-text\">index.js</code>，因为后者还包含非法的 require 语句。这个过程也能在<code class=\"language-text\">index.html</code>文件中体现：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">&lt;!-- index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript Example&lt;/title&gt;\n  &lt;!-- 译注：以下script为引用 --&gt;\n  &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;--\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Hello from HTML!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div>\n<p>刷新浏览器就能发现现在和之前一样了!</p>\n<p>注意每次更改<code class=\"language-text\">index.js</code>，我们都需要运行 webpack 命令。这样很繁琐，并且在使用 webpack 高级功能时会变得更糟（比如从转换后的代码中生成<a href=\"https://webpack.js.org/guides/development/#using-source-maps\">source map</a>辅助调试初始代码）。webpack 可以从项目根目录的配置文件中读取配置，配置文件名为<code class=\"language-text\">webpack.config.js</code>，在本文的例子是这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">// webpack.config.js\nmodule.exports = {\n  mode: &#39;development&#39;,\n  entry: &#39;./index.js&#39;,\n  output: {\n    filename: &#39;main.js&#39;,\n    publicPath: &#39;dist&#39;\n  }\n};</code></pre></div>\n<p>现在每次修改<code class=\"language-text\">index.js</code>时，可以哦那个过下面这条命令运行 webpack：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./node_modules/.bin/webpack</code></pre></div>\n<p>我们不再需要指定<code class=\"language-text\">index.js</code>和<code class=\"language-text\">--mode=development</code>设置了，因为 webpack 会从<code class=\"language-text\">webpack.config.js</code>加载这些配置。现在好些了，但仍显得繁琐，每次修改代码还是需要输入这串命令——下面会让这个过程更简单一些。</p>\n<p>总之，上面这些步骤看起来并不多，但这种流程有巨大的优势。我们不再需要以全局变量的形式加载外部文件了。不必在 HTML 文件里增加<code class=\"language-text\">&lt;script&gt;</code>标签了，所有 JavaScript 的新库都能通过 JavaScript 的<code class=\"language-text\">require</code>语句加载。单一的 JS 打包文件也意味着更好的性能。加入构建过程之后，还可以在工作流中加入其他的强大功能。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/992/1*ee_ivxNTKgIJTjmEMC4-dg.png\"></p>\n<h4>转换代码以支持新语言特性（babel）</h4>\n<p>代码转换是指将一种语言的代码转换为另一种相似语言的代码。这是前端开发的一个重要部分——因为浏览器对新特性的支持进展缓慢，所以新语言的实验性功能得转译为兼容浏览器的语言。</p>\n<p>对 CSS 来说，现在有<a href=\"http://sass-lang.com/\">Sass</a>，<a href=\"http://lesscss.org/\">Less</a>和<a href=\"http://stylus-lang.com/\">Stylus</a>，等等。对 JavaScript 来说，曾经有红极一时的<a href=\"http://coffeescript.org/\">CoffeScript</a>(大约发布于 2010 年)，而现在人们用得最多的则是<a href=\"https://babeljs.io/\">babel</a>和<a href=\"http://www.typescriptlang.org/\">TypeScript</a>。CoffeeScript 这门语言，通过显著改变 JavaScript 来实现优化后者的目的——可选括号，有意义的留白，等等。babel 并不是一个新语言，而是一个转换器，它将所有浏览器尚未支持的新一代 JavaScript 特性（<a href=\"https://babeljs.io/learn-es2015/\">ES2015</a>及之后的版本）转换为更兼容的 ES5 JavaScript 版本。TypeScript 本质上与新一代 JavaScript 相同，但还支持可选的静态类型。很多人选择使用 babel，因为它与原生 JavaScript 最相似。</p>\n<p>看看如何在 webpack 构建过程中使用 babel。首先需要在项目中通过命令行安装 babel（它是个 npm 包）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install @babel/core @babel/preset-env babel-loader --save-dev</code></pre></div>\n<p>注意，作为开发依赖，我们安装了 3 个独立的包——<code class=\"language-text\">@babel/core</code>是 babel 的主题，<code class=\"language-text\">@babel/preset-env</code>是预设，决定转换 JavaScript 的哪些新特性，而<code class=\"language-text\">babel-loader</code>是让 babel 能与 webpack 协同的包。可以编辑<code class=\"language-text\">webpack.config.js</code>来设置 webpack 使用<code class=\"language-text\">babel-loader</code>，方法如下：</p>\n<pre>\n// webpack.config.js\nmodule.exports = {\n  mode: 'development',\n  entry: './index.js',\n  output: {\n    filename: 'main.js',\n    publicPath: 'dist'\n  },\n  <b>\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n    ]\n  }\n  </b>\n};\n</pre>\n<p>语法很不清晰（幸好我们不必经常修改）。基本上就是告诉 webpack 查找每个.js 文件（<code class=\"language-text\">node_modules</code>文件夹里的除外）并使用<code class=\"language-text\">babel-loader</code>通过<code class=\"language-text\">@babel/preset-env</code>的预设进行转换。<a href=\"http://webpack.github.io/docs/configuration.html\">这里</a>有更多关于 webpack 配置的内容。</p>\n<p>配置好了所有东西，现在可以用 ES2015 的语法写 JavaScript 了！下面是在<code class=\"language-text\">index.html</code>中使用 ES2015 <a href=\"https://babeljs.io/learn-es2015/#ecmascript-2015-features-template-strings\">模板字符串(template string)</a>语法的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">// index.js\nvar moment = require(&#39;moment&#39;);\nconsole.log(&quot;Hello from JavaScript!&quot;);\nconsole.log(moment().startOf(&#39;day&#39;).fromNow());\n/*译注：以下为template string*/\nvar name = &quot;Bob&quot;, time = &quot;today&quot;;\nconsole.log(`Hello ${name}, how are you ${time}?`);</code></pre></div>\n<p>还可以使用<a href=\"https://babeljs.io/learn-es2015/#ecmascript-2015-features-modules\">ES2015 import</a>语句代替<code class=\"language-text\">require</code>加载模块，这在目前的代码库中很常见。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">// index.js\n/*译注：import语句*/\nimport moment from &#39;moment&#39;;\n\nconsole.log(&quot;Hello from JavaScript!&quot;);\nconsole.log(moment().startOf(&#39;day&#39;).fromNow());\nvar name = &quot;Bob&quot;, time = &quot;today&quot;;\nconsole.log(`Hello ${name}, how are you ${time}?`);</code></pre></div>\n<p>上例中，<code class=\"language-text\">import</code>语法和<code class=\"language-text\">require</code>没什么区别，但<code class=\"language-text\">import</code>在复杂情况下更灵活。修改<code class=\"language-text\">index.js</code>之后，我们需要通过命令行再运行一次 webpack。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./node_modules/.bin/webpack</code></pre></div>\n<p>现在浏览器里刷新<code class=\"language-text\">index.html</code>。在我写这篇文章的时候，大多数现代浏览器已支持 ES2015 的全部特性，所以证实 babel 是否起作用有点难。你可以尝试用老浏览器比如 IE9，或者在<code class=\"language-text\">bundle.js</code>里搜索转换后的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">// bundle.js\n// ...\nconsole.log(&#39;Hello &#39; + name + &#39;, how are you &#39; + time + &#39;?&#39;);\n// ...</code></pre></div>\n<p>这段代码可以看到，为了兼容浏览器， babel 把 ES2015 的模板字符串转换为了普通 JavaScript 字符串拼接。可能这个例子没什么大不了的，但代码转换这个功能真的非常强大。比如<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">async/await</a>这种让人激动的 JavaScript 新功能，能够让你写出更好的代码。尽管代码转换有时显得既繁琐又痛苦，但在过去几年中它确实大大改善了 JavaScript 这门语言，因为它让开发者能够在当下测试未来的语言特性。</p>\n<p>还有一些没提到的内容，马上就完了。如果关注性能，我们应该<a href=\"https://en.wikipedia.org/wiki/Minification_%28programming%29\">压缩(minifying)</a>打包后的文件。考虑到已经引入了构建过程，实现这个目标应该不难。我们每次修改代码后，也必须重新运行 webpack 命令行。下一步，我们将关注有哪些工具能够帮助我们。</p>\n<h4>使用任务管理工具（npm scripts）</h4>\n<p>我们已经使用构建过程来处理 JavaScript 模块了，自然也该使用任务管理工具。它能够自动化构建过程中的各个步骤。对前端开发来说，任务包括压缩代码，优化图片，执行测试等等。</p>\n<p>2013 年，grunt 是最普及的任务管理工具，随后出现了 gulp 。二者都依赖内置了其他命令行工具的插件。现在最受欢迎的工具似乎是 npm 包管理器内置的脚本，它不需要插件，直接调用其他命令行工具。</p>\n<p>写几个 npm 脚本，方便我们使用 webpack。只需要简单修改<code class=\"language-text\">package.json</code>文件：</p>\n<pre>\n{\n  \"name\": \"modern-javascript-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    <b>\n    \"build\": \"webpack --progress --mode=production\",\n    \"watch\": \"webpack --progress --watch\"\n    </b>\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"moment\": \"^2.22.2\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.0.0\",\n    \"@babel/preset-env\": \"^7.0.0\",\n    \"babel-loader\": \"^8.0.2\",\n    \"webpack\": \"^4.17.1\",\n    \"webpack-cli\": \"^3.1.0\"\n  }\n}</pre>\n<p>我们增加了 2 个新脚本，<code class=\"language-text\">build</code>和<code class=\"language-text\">watch</code>。执行 build 脚本，可以在命令行输入：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm run build</code></pre></div>\n<p>这条命令会运行 webpack（使用<code class=\"language-text\">wepack.config.js</code>的配置），其中<code class=\"language-text\">--progress</code>参数会显示进度百分比，而<code class=\"language-text\">--mode=production</code>参数会为生产环境压缩代码。要执行<code class=\"language-text\">watch</code>脚本：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm run watch</code></pre></div>\n<p>这条命令使用<code class=\"language-text\">--watch</code>参数，每次有 JavaScript 文件修改时，就自动重新运行 webpack。开发的福音。</p>\n<p>注意在<code class=\"language-text\">package.json</code>中的脚本执行时，不必指定完整路径，因为 node.js 知道每个 npm 模块的路径。太方便了！我们还可以安装 webpack-dev-server 让事情变得更方便，它是一个独立工具，能够创建一个实时加载的 web 服务器。把它作为开发依赖安装，输入以下命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install webpack-dev-server --save-dev</code></pre></div>\n<p>随后在<code class=\"language-text\">package.json</code>中添加一条 npm 脚本：</p>\n<pre>\n{\n  \"name\": \"modern-javascript-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --progress -p\",\n    \"watch\": \"webpack --progress --watch\",\n    <b>\n    \"server\": \"webpack-dev-server --open\"\n    </b>\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"moment\": \"^2.19.1\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.0.0\",\n    \"@babel/preset-env\": \"^7.0.0\",\n    \"babel-loader\": \"^8.0.2\",\n    \"webpack\": \"^3.7.1\",\n    \"webpack-dev-server\": \"^3.1.6\"\n  }\n}</pre>\n<p>现在可以通过命令来启动开发服务器了：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm run server</code></pre></div>\n<p>这条命令默认通过<code class=\"language-text\">localhost：8080</code>，自动在浏览器打开<code class=\"language-text\">index.html</code>网站。每次在<code class=\"language-text\">index.js</code>文件中修改代码，wepack-dev-server 都会重新构建打包文件，并自动刷新浏览器。它能大大节约我们的时间，因为这让我们只关注代码，而不必在浏览器效果与代码之间不断切换。</p>\n<p>上面的内容只是一点皮毛，关于 webpack 和 webpack-dev-server 还有很多设置（更多内容看<a href=\"https://webpack.js.org/guides/development/\">这里</a>）。你当然也可以使用 npm 脚本完成其他任务，比如把 Sass 转换为 CSS，压缩图片，执行测试——所有可以通过命令行完成的任务。npm 脚本自身还有一些高级设置和技巧——<a href=\"https://twitter.com/k88hudson\">Kate Hudson</a>这个<a href=\"https://www.youtube.com/watch?v=0RYETb9YVrk\">演讲</a>很不错：</p>\n<p><img src=\"https://i.ytimg.com/vi/0RYETb9YVrk/hqdefault.jpg\"></p>\n<h4>结语</h4>\n<p>总而言之，这就是现代 JavaScript。我们从只用 HTML 和 JS，到了使用<strong>包管理器</strong>自动下载第三方包，到使用<strong>模块打包工具</strong>创建单一脚本文件，再到使用<strong>转换器</strong>使用未来 JavaScript 特性，最后到使用<strong>任务管理工具</strong>自动化构建过程的各个步骤。内容很多，对新手尤甚。web 开发曾经是一个对新手友好的领域，主要是因为它易于上手；但现在却让人望而却步，尤其是各种快速变化的工具。</p>\n<p>但它并没有看起来那么可怕。生态正在稳定，特别是在前端拥抱 node 生态之后。npm 包管理器、node 模块中的 require 和 import 语句、还有任务管理工具 npm 脚本，他们都容易上手并且很少出差错。现在的工作流相比一两年之前已经大大简化了。</p>\n<p>现在的框架对新手和老手开发者一视同仁，通常自带初始配置工具。Ember 有<a href=\"https://ember-cli.com/\"><code class=\"language-text\">ember-cli</code></a>，它对 Angular 的<a href=\"https://cli.angular.io/\"><code class=\"language-text\">angular-cli</code></a>产生了极大影响，还有 React 的<a href=\"https://github.com/facebookincubator/create-react-app\"><code class=\"language-text\">create-react-app</code></a>，Vue 的<a href=\"https://github.com/vuejs/vue-cli\"><code class=\"language-text\">vue-cli</code></a>等等。这些工具会配置好一个项目的所有依赖——你可以直接开始写代码。但是，这些工具并非奇迹，它们也只是按照一定规则和可用性配置好了全部东西——你可能经常遇到需要额外配置 webpack，babel 的情况。所以理解每个工具的作用仍然至关重要，这正是本文所介绍的内容。</p>\n<p>现代 JavaScript 时常令人沮丧，因为它还在不停变化和升级。尽管看起来像是在不停的“造轮子”，但 JavaScript 的快速升级确实推动了一系列创新，比如 hot-reloading、real-time linting 和 time-travel debugging 等。开发是一项令人兴奋的工作，希望本文的内容能够帮助你在开发道路上走得更远。\n<img src=\"https://cdn-images-1.medium.com/max/992/1*H6NN_RxZNeVyLYpCirsslg.png\"></p>","frontmatter":{"date":null,"title":"","image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAABwkC0D//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAERACAhMUH/2gAIAQEAAT8hQT3McFf/2gAMAwEAAgADAAAAEDDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAECExUWFx/9oACAEBAAE/EFAwDTvCXwelxjkZSr//2Q==","aspectRatio":1.5056179775280898,"src":"/static/9983387778f1c70c0ce32374522d12c6/d7b72/post-default-bg.jpg","srcSet":"/static/9983387778f1c70c0ce32374522d12c6/2347c/post-default-bg.jpg 750w,\n/static/9983387778f1c70c0ce32374522d12c6/5a448/post-default-bg.jpg 1500w,\n/static/9983387778f1c70c0ce32374522d12c6/d7b72/post-default-bg.jpg 3000w,\n/static/9983387778f1c70c0ce32374522d12c6/439d2/post-default-bg.jpg 4288w","sizes":"(max-width: 3000px) 100vw, 3000px"}}}}}},"pageContext":{"slug":"/Blog/[译]写给恐龙的现代Javascript指南/","previous":{"fields":{"slug":"/Blog/test7/"},"frontmatter":{"title":"Sweet Pandas Eating Sweets"}},"next":{"fields":{"slug":"/Blog/一次搞笑而深刻的bug调试/"},"frontmatter":{"title":""}}}}