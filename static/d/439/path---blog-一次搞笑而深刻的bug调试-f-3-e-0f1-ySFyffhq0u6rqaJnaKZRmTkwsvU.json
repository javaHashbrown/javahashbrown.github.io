{"data":{"markdownRemark":{"id":"49b38d29-676b-5415-9c5e-99a926b44863","excerpt":"问题出现 APP某个页面加载时访问了2个API，两者的返回数据都分别有 字段，用于区分对应的数据列表中项目的类别，前端界面再根据类别渲染不同的界面   这个时候问题出现了，第一个API一切正常，第二个API…","html":"<h4>问题出现</h4>\n<blockquote>\n<p>APP某个页面加载时访问了2个API，两者的返回数据都分别有<code class=\"language-text\">type</code>字段，用于区分对应的数据列表中项目的类别，前端界面再根据类别渲染不同的界面  </p>\n</blockquote>\n<p>这个时候问题出现了，第一个API一切正常，第二个API返回列表本应全是<code class=\"language-text\">type=1</code>的数据类型，但是每次返回的第一条数据都是<code class=\"language-text\">type=2</code></p>\n<h4>调试</h4>\n<ol>\n<li>\n<p>很自然打开<code class=\"language-text\">chrome devTool</code>，打印并查看后台返回数据，嗯，返回的数据<code class=\"language-text\">type=2</code>，看来是后台问题可能性较大 </p>\n</li>\n<li>\n<p>再次确认，用<code class=\"language-text\">postman</code>请求一次接口看看返回数据，咦，怎么返回数据又对了，<code class=\"language-text\">type=1</code>，反复试了几次，还是对的</p>\n</li>\n<li>\n<p>换了一个API测试工具，结果和2一样，看样子应该是前端的问题了，而且应该是网络层的问题，而网络层是基于axios封装的，也就是说axios有问题？ </p>\n</li>\n<li>\n<p>还是觉得需要首先排除后台原因，于是让后台同事打印出接口返回数据，对比之后发现和API工具结果一致，基本排除后端责任</p>\n</li>\n<li>\n<p>深入到封装的网络层查看<code class=\"language-text\">axios</code>返回的数据，链式函数里淘宝，分别打印了<code class=\"language-text\">response=&gt;response.data</code>，二者数据一致错误，数据bug复现</p>\n</li>\n<li>\n<p>怀疑axios老版本不可靠，于是升级到最新版，继续测试，问题依旧</p>\n</li>\n<li>\n<p>开始axios请求的头部是<code class=\"language-text\">json</code>，移植之前封装的另一版本网络层代码，头部使用<code class=\"language-text\">arraybuffer</code>, 解码后<code class=\"language-text\">response</code>的数据与后台一致了，\n但是<code class=\"language-text\">response.data</code>数据仍错误，因为二者间只多了一次<code class=\"language-text\">JSON.parse</code>,定位问题在<code class=\"language-text\">JSON.parse</code></p>\n</li>\n<li>\n<p>因为JSON.parse本身不会有问题，再次开始怀疑bug源于后端，返回的json字符串格式不标准导致解析错误，可用解析工具可以顺利解析出json，这里没有问题  </p>\n</li>\n<li>\n<p>病急乱投医，怀疑2个接口同时请求有问题，于是注释第一个正常API的所有网络访问代码，返回结果一致，看来接口没有相关性，问题独立出现在第二个接口上  </p>\n</li>\n<li>\n<p>复制API调试工具的返回json，同时网络层截断发往结果异常API接口的所有网络访问，把复制的json作为固定数据返回给\n<code class=\"language-text\">response</code>，错误依旧，问题确定位在前端了</p>\n</li>\n<li>\n<p>把10中的json里的type属性改名为mode，axios解析的数据正常了</p>\n</li>\n<li>\n<p>继续看axios封装内容，<code class=\"language-text\">.then(response=&gt;{...})</code>同时打印<code class=\"language-text\">response， JSON.parse(response.data)</code>, 数据又正确了，并且打印出数据一致。\n基本排除axios错误的可能性，那么就只剩下前端页面代码bug这一种可能性了，开始从网络层逐渐向应用层排查  </p>\n</li>\n<li>\n<p>最后可耻的在reducer里发现了自己写死的代码<code class=\"language-text\">response[0].type = 2</code>, 根源找到</p>\n</li>\n</ol>\n<p><strong>总耗时： 8小时</strong></p>\n<h4>原因</h4>\n<p>简单说就是chrome的console.log打印对象时，如果对象后续值被修改了，打印的值也会随之改变，除非打印时就立刻展开对象的所有属性</p>\n<p><code class=\"language-text\">stackoverflow</code>找到了问题，这个问题（或者说bug）起源于webkit的一个bug  <a href=\"https://stackoverflow.com/questions/11284663/console-log-shows-the-changed-value-of-a-variable-before-the-value-actually-ch%5D\"><code class=\"language-text\">stackoverflow问题地址</code></a></p>\n<blockquote>\n<p>Excerpts from the original bug report ([https://bugs.webkit.org/show_bug.cgi?id=35801]):</p>\n<p>Description From mitch kramer 2010-03-05 11:37:45 PST</p>\n<ol>\n<li>\n<p>create an object literal with one or more properties</p>\n</li>\n<li>\n<p>console.log that object but leave it closed (don't expand it in the console)</p>\n</li>\n<li>\n<p>change one of the properties to a new value</p>\n</li>\n</ol>\n<p>now open that console.log and you'll see it has the new value for some reason, even though it's value was different at the time it was generated.</p>\n<p>I should point out that if you open it, it will retain the correct value if that wasn't clear.</p>\n</blockquote>\n<h4>规避方法</h4>\n<ul>\n<li>\n<p>创建对象的一个深拷贝，使它不受后续的影响， 比如把对象转成字符串再读取回来</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">JSON.parse( JSON.stringify( object ) )</code></pre></div>\n</li>\n</ul>\n<blockquote>\n<h2>应验了一句老话，眼见也未必为实，今天体会很深</h2>\n</blockquote>","frontmatter":{"date":null,"title":"","image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAABwkC0D//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAERACAhMUH/2gAIAQEAAT8hQT3McFf/2gAMAwEAAgADAAAAEDDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAECExUWFx/9oACAEBAAE/EFAwDTvCXwelxjkZSr//2Q==","aspectRatio":1.5056179775280898,"src":"/static/9983387778f1c70c0ce32374522d12c6/d7b72/post-default-bg.jpg","srcSet":"/static/9983387778f1c70c0ce32374522d12c6/2347c/post-default-bg.jpg 750w,\n/static/9983387778f1c70c0ce32374522d12c6/5a448/post-default-bg.jpg 1500w,\n/static/9983387778f1c70c0ce32374522d12c6/d7b72/post-default-bg.jpg 3000w,\n/static/9983387778f1c70c0ce32374522d12c6/439d2/post-default-bg.jpg 4288w","sizes":"(max-width: 3000px) 100vw, 3000px"}}}}}},"pageContext":{"slug":"/Blog/一次搞笑而深刻的bug调试/","previous":{"fields":{"slug":"/Blog/test7/"},"frontmatter":{"title":"Sweet Pandas Eating Sweets"}},"next":{"fields":{"slug":"/Blog/[译]写给恐龙的现代Javascript指南/"},"frontmatter":{"title":""}}}}