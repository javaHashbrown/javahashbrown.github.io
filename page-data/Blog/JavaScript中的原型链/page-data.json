{"componentChunkName":"component---src-templates-post-post-js","path":"/Blog/JavaScript中的原型链/","result":{"data":{"markdownRemark":{"id":"3f2a1e16-aa8f-5c90-a824-edea76e7b8b4","excerpt":"原型链的前提规则 原型链关系试验 试验的一点解释 原型链关系图 原型链的前提规则 任何对象都拥有__proto__属性，指向其 构造函数 (constructor function) 的 原型 (prototype) 对象 例： 假设有数组对象 a…","html":"<ul>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%89%8D%E6%8F%90%E8%A7%84%E5%88%99\">原型链的前提规则</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%85%B3%E7%B3%BB%E8%AF%95%E9%AA%8C\">原型链关系试验</a></li>\n<li><a href=\"#%E8%AF%95%E9%AA%8C%E7%9A%84%E4%B8%80%E7%82%B9%E8%A7%A3%E9%87%8A\">试验的一点解释</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%85%B3%E7%B3%BB%E5%9B%BE\">原型链关系图</a></li>\n</ul>\n<hr>\n<h3 id=\"原型链的前提规则\" style=\"position:relative;\"><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%89%8D%E6%8F%90%E8%A7%84%E5%88%99\" aria-label=\"原型链的前提规则 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>原型链的前提规则</h3>\n<ol>\n<li>\n<p><strong>任何对象都拥有<code>__proto__</code>属性，指向其 <code>构造函数 (constructor function)</code> 的 <code>原型 (prototype)</code> 对象</strong></p>\n<ul>\n<li>例： 假设有数组对象 a，因为它是由数组构造函数<code>Array</code>创建的，那么<code>a.__proto__</code>将指向<code>Array.prototype</code></li>\n</ul>\n</li>\n</ol>\n<p>这里可以引申出 2 个推论：</p>\n<blockquote>\n<p><strong>推论 1.1</strong>：因为<code>构造函数 (constructor function)</code>是函数，而函数都是对象，所以构造函数也是对象。它也有<code>__proto__</code>属性，<code>__proto__</code>指向构造函数之构造函数的<code>原型 (prototype)</code> 对象；</p>\n</blockquote>\n<blockquote>\n<p><strong>推论 1.2</strong>：<code>原型 (prototype)</code> 对象也是对象，所以也有<code>__proto__</code>属性，并指向 Object 构造函数原型<code>Object.prototype</code>；</p>\n</blockquote>\n<p><strong>疑问 1.1</strong>：<code>Object.prototype</code>是否也是对象？如果是，那么它也应该有<code>__proto__</code>属性，这个属性应该指向它自身？如果不是对象，那它是什么？</p>\n<ol start=\"2\">\n<li>\n<p><strong>任何函数都是 <code>函数 (Function)</code> 创建的实例，且拥有<code>prototype</code>属性，该属性指向函数对应的<code>原型 (prototype)</code> 对象<code>Function.prototype</code></strong></p>\n<p>根据 2 和推论 1.1，可以得到推论：</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>推论 2.1</strong>：构造函数既是对象，又是函数实例，因此它不仅拥有<code>__proto__</code>属性，也拥有<code>prototype</code>属性</p>\n</blockquote>\n<blockquote>\n<p><strong>推论 2.2</strong>：构造函数的<code>__proto__</code>属性指向其上一级构造函数<code>原型 (prototype)</code> 对象，即<code>Function.prototype</code>, 它的<code>prototype</code>属性指向<code>[[constructor]].prototype</code></p>\n</blockquote>\n<p><strong>疑问 2.1</strong>：<code>Function</code>作为元构造函数，其自身又是哪个构造函数的实例呢？如果<code>Function</code>是自身的实例，那么其<code>__proto__</code>属性应该指向<code>Function.prototype</code>；如果不是，它的<code>__proto__</code>属性会指向哪里？</p>\n<ol start=\"3\">\n<li>\n<p><strong>构造函数的<code>原型 (prototype)</code>对象都有一个<code>构造函数(constructor)</code>属性，指向其对应的构造函数</strong></p>\n<ul>\n<li>例：即 Array.prototype.constructor 将指向 Array</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"原型链关系试验\" style=\"position:relative;\"><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%85%B3%E7%B3%BB%E8%AF%95%E9%AA%8C\" aria-label=\"原型链关系试验 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>原型链关系试验</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/*** 疑问1.1 ***/</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'object'</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">//解释：Object.prototype是对象，按照基础概念1，它有__proto__属性</span>\n\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span> <span class=\"token comment\">// null</span>\n<span class=\"token comment\">//解释：Object.prototype.__proto__指向null，它没有__proto__属性</span>\n\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">//解释：Object.prototype不是Object的实例</span>\n\n<span class=\"token comment\">/************************************************************/</span>\n\n<span class=\"token comment\">/*** 疑问2.1***/</span>\n<span class=\"token keyword\">typeof</span> Function<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'function'</span>\nFunction <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nFunction <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">//解释：Function是构造函数，它是函数，也是对象，所以既有prototype属性，也有__proto__属性</span>\n\nFunction<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">==</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">//解释：根据推论1.1，Function的构造函数是它自己</span>\n\n<span class=\"token keyword\">typeof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'function'</span>\n<span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">//解释：Function.prototype是函数，但它没有prototype属性</span>\n\n<span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// fasle</span>\n<span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">==</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">//解释：Function.prototype是函数，但它不是Function的实例，却是Object的实例</span>\n\n<span class=\"token keyword\">typeof</span> Object<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'function'</span>\nObject <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nObject<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">==</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">//解释：Object是构造函数，它是Function的实例</span></code></pre></div>\n<p>这里出现了 2 个矛盾点，集中在<code>Object.prototype</code>和<code>Function.prototype</code>这 2 个对象：</p>\n<ol>\n<li><code>Object.prototype</code>是对象，却不是 Object 创建的</li>\n<li><code>Function.prototype</code>是函数，却不是 Function 创建的，而是由 Object 创建，但 Object 明明是 Function 的实例</li>\n</ol>\n<p>如果说按照常理，第一点已经怪异到看不懂，那么第二点则是直接变成了“先有鸡 （Function），还是先有蛋 （Object）”的哲学拷问。</p>\n<h3 id=\"试验的一点解释\" style=\"position:relative;\"><a href=\"#%E8%AF%95%E9%AA%8C%E7%9A%84%E4%B8%80%E7%82%B9%E8%A7%A3%E9%87%8A\" aria-label=\"试验的一点解释 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>试验的一点解释</h3>\n<p>逻辑上这样自然说不通，那么只能说明一开始的前提规则错了，或者更具体点说，提到的这 2 个对象是超越规则的存在，不受前提规则的约束。查了下标准，果然这两个东西是基于规则创建的，为了兼容旧版本 JS 设定了一些规则，和构造函数其实没什么关系。</p>\n<p><strong>关于 Object.prototype（注意加粗部分）</strong></p>\n<blockquote>\n<p>ECMA-262 19.1.3 Properties of the Object Prototype Object</p>\n<p>The Object prototype object is the intrinsic object %ObjectPrototype%. <strong>The Object prototype object is an ordinary object</strong>.</p>\n<p><strong>The value of the [[Prototype]] internal slot of the Object prototype object is null</strong> and the initial value of the [[Extensible]] internal slot is true.</p>\n</blockquote>\n<p><strong>关于 Function.prototype（注意加粗部分）</strong></p>\n<blockquote>\n<p>ECMA-262 19.2.3 Properties of the Function Prototype Object</p>\n<p>The Function prototype object is the intrinsic object %FunctionPrototype%. The Function prototype object is itself a built-in function object. When invoked, it accepts any arguments and returns undefined. It does not have a [[Construct]] internal method so it is not a constructor.</p>\n<p><strong>NOTE - The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</strong></p>\n<p>The value of the [[Prototype]] internal slot of the Function prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The initial value of the [[Extensible]] internal slot of the Function prototype object is true.</p>\n<p><strong>The Function prototype object does not have a prototype property.</strong></p>\n<p>The value of the length property of the Function prototype object is 0.</p>\n<p>The value of the name property of the Function prototype object is the empty String.</p>\n</blockquote>\n<h3 id=\"原型链关系图\" style=\"position:relative;\"><a href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%85%B3%E7%B3%BB%E5%9B%BE\" aria-label=\"原型链关系图 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>原型链关系图</h3>\n<p>最后附上一张自己理解的图，权当费脑子的证明吧</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8408bc9eeee980cacec0824f454c744c/db664/prototype-chain.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAABJNAAASTQHzl8SnAAABg0lEQVQoz22S207CQBCGeQND5NQ9zey2ZUtbSkDFImdBL9FLCRhjvFKfAB8AH8R4p+/oFIyiIdlsOjvzz3wz05xS+HNA4Wr18v72tl6/Sgm7rr0n989mTKJQzBFyY2YpQCMaAL1fTHGYGaABra3WozAILJKG3sEILouFkuPwPWJCdRUahT5iTZs4jhpxGIWhi8ZAlrR7mj7c3Y9HY8GFgr9ib1OWM2E93w8ih0vFOHMo8LuLqm9Hg1GreYRCugpUNovtjTkNmrCb9cTaGnXYaaeLm/nlZOpJadBQxl7aSdOzWhgRIwW7uG0+S0HYBGdms6tGnICEVqM5PZ+mna4PNCUaQW25WM7niyRJEFFr19PmFxsBKw7P5w8ZE4gu5yJtp2GcEGTV8wnq4CAfBGG/P7S+NVJp1HJLTmJWLD8/Pn18fPZ6g3LZoZVcza5PWsfc4fRtDOHDZHKxXN4mUUwzo5ffylRwOBiRL4rqnKaldIEWw2gxWQUhFAWVSpUMLfPi7s/zBTtpWvy81tIMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"prototype chain\"\n        title=\"prototype chain\"\n        src=\"/static/8408bc9eeee980cacec0824f454c744c/c1b63/prototype-chain.png\"\n        srcset=\"/static/8408bc9eeee980cacec0824f454c744c/5a46d/prototype-chain.png 300w,\n/static/8408bc9eeee980cacec0824f454c744c/0a47e/prototype-chain.png 600w,\n/static/8408bc9eeee980cacec0824f454c744c/c1b63/prototype-chain.png 1200w,\n/static/8408bc9eeee980cacec0824f454c744c/d61c2/prototype-chain.png 1800w,\n/static/8408bc9eeee980cacec0824f454c744c/97a96/prototype-chain.png 2400w,\n/static/8408bc9eeee980cacec0824f454c744c/db664/prototype-chain.png 2509w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","frontmatter":{"date":"March 24, 2019","title":"JavaScript中的原型链","image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAABwkC0D//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAERACAhMUH/2gAIAQEAAT8hQT3McFf/2gAMAwEAAgADAAAAEDDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAECExUWFx/9oACAEBAAE/EFAwDTvCXwelxjkZSr//2Q==","aspectRatio":1.5060240963855422,"src":"/static/9983387778f1c70c0ce32374522d12c6/7a34f/post-default-bg.jpg","srcSet":"/static/9983387778f1c70c0ce32374522d12c6/72227/post-default-bg.jpg 750w,\n/static/9983387778f1c70c0ce32374522d12c6/d41e0/post-default-bg.jpg 1500w,\n/static/9983387778f1c70c0ce32374522d12c6/7a34f/post-default-bg.jpg 3000w,\n/static/9983387778f1c70c0ce32374522d12c6/76224/post-default-bg.jpg 4288w","sizes":"(max-width: 3000px) 100vw, 3000px"}}}}}},"pageContext":{"slug":"/Blog/JavaScript中的原型链/","previous":{"fields":{"slug":"/Blog/判断有序数组B是否为有序数组A的子集/"},"frontmatter":{"title":"判断有序数组B是否为有序数组A的子集"}},"next":{"fields":{"slug":"/Blog/2019半年小结/"},"frontmatter":{"title":"2019半年小结"}}}}}